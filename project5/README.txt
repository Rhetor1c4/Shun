project5

a）sm2.py：SM2的基础实现。主要函数模块如下： 
1. inv(a, n)：使用扩展欧几里得算法计算模逆。输入为整数a、模数n，输出a⁻¹ mod n。
2. add(P, Q)：椭圆曲线点加法（含点加倍）。输入两点P(x₁,y₁)和Q(x₂,y₂)，输出P+Q的结果点或无穷远点。
3. mul(k, P)：标量乘法（Double-and-Add算法）。输入标量k、基点P，输出kP的结果点。
4. sm3_hash(data)：模拟SM3哈希。输入字节数据data，输出256位哈希值。
5. compute_ZA(IDA, P)：计算SM2签名所需的用户标识哈希ZA。输入用户ID IDA，公钥P(x,y)，输出ZA = H(ENTL∥IDA∥a∥b∥xG∥yG∥xA∥yA)。
6. kdf(Z, klen)：密钥派生函数（用于加密生成对称密钥）。输入字节Z、密钥长度klen，输出派生密钥字节流。
7. key_gen()：生成SM2密钥对。输出私钥d，公钥P=dG。
8. sign(d, M, IDA)：标准SM2签名。输入私钥d，消息M，用户ID IDA，输出签名(r, s)。
9. verify(P, M, signature, IDA)：验证签名。输入公钥P，消息M，签名(r,s)，用户ID IDA，输出验证结果（True/False）。
10. encrypt(P, M)：加密消息。输入公钥P，明文M，输出密文C = C1∥C2∥C3。
11. decrypt(d, C)：解密密文。输入私钥d，密文C，输出明文M或错误。
可以看到我们成功实现了sm2。

sm2-opt1.py：在基础实现上进行了如下优化：
1. 椭圆曲线运算优化：使用雅可比坐标系统减少模逆运算，实现窗口法标量乘法，预计算常用点，添加同时乘法算法优化多点乘法；
2. 内存管理优化：使用bytearray和内存视图减少内存分配，重用缓冲区避免重复创建对象，优化大数转换处理；
3. 算法改进：改进KDF实现，减少内存分配，优化模逆运算实现，添加预计算表加速重复运算；
4. 其他优化：改进错误处理，优化数据结构选择。
优化后，效率也有进一步提升。

b）SM2签名算法误用分析与POC验证。几种误用情况如下：
1. 重用k值导致私钥泄露。
签名过程：
1.	e = Hash(ZA || M)
2.	生成随机数 k ∈ [1, n-1]
3.	(x1, y1) = kG
4.	r = (e + x1) mod n
5.	s = ((1 + d)^-1 * (k - r*d)) mod n
攻击推导：
当同一用户对两条消息M₁、M₂使用相同k值签名时：
s₁ = (1 + d)^-1 * (k - r₁*d) mod n
s₂ = (1 + d)^-1 * (k - r₂*d) mod n
可以解方程组得到：
d = (s₂ - s₁) / (s₁ - s₂ + r₁ - r₂) mod n
2. 不同用户使用相同k值。
推导：
用户A和B使用相同k值签名：
对A: s₁ = (1 + dA)^-1 * (k - r₁*dA) mod n  
对B: s₂ = (1 + dB)^-1 * (k - r₂*dB) mod n
可分别恢复：
dA = (k - s₁) / (s₁ + r₁) mod n  
dB = (k - s₂) / (s₂ + r₂) mod n
3. 与ECDSA使用相同d和k。
联合推导：
从ECDSA签名：
k = (Hash(m) + r₁*d) * s₁^-1 mod n
从SM2签名：
k = s₂*(1 + d) + r₂*d mod n
联立解得：
d = (s₁*s₂ - Hash(m)) / (r₁ - s₁*s₂ - s₁*r₂) mod n
4. 签名可延展性问题
分析：
由于SM2验证方程对称性，(r,s)和(r,-s)都是有效签名，可能导致区块链网络分裂。
POC验证如代码poc.py所示。

22密码2班 梁钰舜 202200460175


