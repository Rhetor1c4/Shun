project4

a）sm3.cpp：sm3算法的基础实现。在程序中，我们主要设置以下核心数据结构：哈希状态（state数组）：8个32位变量（共256位），存储算法中间状态和最终结果；消息缓冲区（buffer）：64字节块，用于暂存不足一个块的数据；长度计数器（total_len, buffer_len）：记录已处理数据总长度和缓冲区当前长度。
使用如下主要功能部件：
reset函数：初始化，重置算法到初始状态。设置初始IV值（8个固定常量），清零长度计数器，并清空消息缓冲区；
update函数：消息处理，增量式处理输入数据。将新数据与缓冲区残留数据组合，每当凑满64字节块时调用process_block处理，剩余数据存入缓冲区等待后续输入；
final函数：最终处理，处理尾部数据并输出哈希值。填充，按SM3规范添加比特"1"和多个"0"；添加长度，将原始消息位长度附加到末尾；处理最后块，调用压缩函数处理填充后的数据；输出转换，将state数组转换为32字节哈希值。
核心算法部件主要是压缩函数process_block。其主要操作有：
消息扩展：将64字节块扩展为68个32位字（W数组），额外生成64个32位字（W'数组），使用P1置换函数进行非线性扩展；
状态更新：8轮循环（共64步）迭代处理，每步使用布尔函数FF/GG（随轮次变化）、置换函数P0，预定义常量Tj，最终与初始状态异或得到新状态。
辅助函数有：FF/GG函数，随轮次变化的非线性逻辑函数；P0/P1置换函数，通过循环移位实现扩散；rotate_left，32位循环左移操作。
其他还有将二进制哈希值转换为十六进制字符串的bytes_to_hex函数和性能测试函数（生成测试数据/计时/统计）performance_test。
我们分别测试3个字符串计算，然后进行十轮效率测试。

sm3-opt1.cpp：基于基础实现，对于算法进行了优化。主要进行了以下优化：
循环展开：将压缩函数的主循环手动展开（每次处理4轮），减少分支预测失败和循环控制开销；
并行计算：在消息扩展阶段同时计算多个W/W'数组元素，提高指令级并行度；
内联函数：所有辅助函数都声明为inline；
常量预计算：提前计算Tj常量数组，避免运行时重复计算。
可以看到，我们优化后，效率有较为显著的提升。

b）sm3-lea.cpp：SM3长度扩展攻击验证。在原有sm3实现的基础上，我们主要实现了以下几个关键部分：
1. SM3类增强功能。为支持长度扩展攻击，我们在原有SM3类基础上扩展了关键功能：
reset_from_state(new_state, known_len)，从已知的哈希状态和消息长度初始化SM3实例，攻击者通过原始哈希值反推出内部状态后，可以用此函数恢复计算上下文；
get_state()，获取当前内部状态（8个32位变量），调试和验证状态恢复是否正确；
get_total_len()，获取已处理消息的总长度，计算填充时需要知道原始消息长度。
2. 攻击辅助工具函数。
create_padding(original_len)，根据RFC规范构造填充块。计算需要填充的字节数（至少1字节0x80 + 长度编码8字节），然后填充0x00使总长度对齐到64字节（SM3块大小），追加原始消息的位长度（64位大端序）。最终输出填充字节序列（如[0x80, 0x00..., 0x00, len_high, ..., len_low]）。
3. 攻击流程实现。
length_extension_attack()，分步骤实现攻击逻辑：
模拟正常哈希计算：计算 Hash(secret_key || original_message) 作为目标哈希，模拟服务器已知但攻击者不可见的原始数据；
从哈希值恢复状态：将32字节哈希值拆解为8个32位整数（SM3的最终状态），通过reset_from_state()恢复SM3实例到最终状态；
构造恶意扩展：计算原始消息（含密钥）的总长度，生成符合规范的填充块（create_padding），拼接任意恶意数据（如malicious_extension）；
计算攻击哈希：用恢复的状态继续哈希计算Hash(secret_key || original_message || padding || malicious_extension)，无需知道密钥，仅依赖原始哈希值；
验证攻击结果：实际计算完整消息的哈希值进行对比，确认攻击生成的哈希是否与真实值匹配。
从结果可以看到我们成功地验证了长度扩展攻击。

c）merkle_tree.cpp：我们根据RFC6962构建了Merkle树（10w叶子节点），并构建了叶子的存在性证明和不存在性证明。
构建流程：
1. RFC6962MerkleTree(leaves)
输入：排序后的叶子节点数据（如10万个哈希值）；
处理逻辑：
填充至2的幂：通过复制最后一个节点，使叶子数满足2ⁿ（保证树结构平衡）；
哈希叶子节点：对每个叶子数据添加前缀0x00后计算SM3哈希（RFC6962规范）；
构建树层级：递归合并相邻节点，直到生成根哈希；
关键操作：
hash_leaf(leaf)：计算叶子节点哈希（前缀0x00）；
hash_node(left, right)：计算内部节点哈希（前缀0x01，左节点优先）。
2. build_tree()
功能：自底向上构建树结构。
过程：每层将相邻两个节点合并为父节点（左小右大）；若节点数为奇数，复制最后一个节点作为配对。

存在性证明（Inclusion Proof）：
1. generate_inclusion_proof(index)
输入：目标叶子节点的索引；
输出：从叶子到根的路径上所有兄弟节点的哈希列表；
逻辑：
从叶子层出发，向上追踪到根；
每层记录当前节点的兄弟节点哈希；
最终返回的证明序列按从叶子到根的顺序排列；
2. verify_inclusion_proof(leaf_hash, proof, root_hash)
验证逻辑：
从叶子哈希开始，依次与证明中的兄弟哈希合并，合并时遵循RFC6962顺序规则（较小哈希在左）；
最终计算结果应与根哈希一致。

不存在性证明（Exclusion Proof）
1. generate_exclusion_proof(leaf_hash)
输入：待证明不存在的叶子哈希；
输出：相邻叶子节点的存在性证明 + 位置标记；
逻辑：
检查叶子是否真的不存在（若存在则抛出异常）；
找到目标哈希在排序叶子中的插入位置；
返回该位置前后叶子的存在性证明（证明它们之间无目标节点）；
2. verify_exclusion_proof(leaf_hash, proof, root_hash)
验证逻辑：
检查相邻叶子的存在性证明是否有效；
确认目标哈希确实不在相邻叶子之间（通过排序性质）。

取实验用例，结果如图。

22密码2班 梁钰舜 202200460175




